-- -------------------------------------------------------------
-- 
-- File Name: /home/apurvan/BBU/CRCoder_export/hdlsrc/ltehdlCRCDecoderModel/CRCGenerator.vhd
-- Created: 2019-12-10 03:50:22
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CRCGenerator
-- Source Path: ltehdlCRCDecoderModel/HDL Algorithm/CRC Decoder/CRCGenerator
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY CRCGenerator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataIn                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        startIn                           :   IN    std_logic;  -- ufix1
        endIn                             :   IN    std_logic;  -- ufix1
        validIn                           :   IN    std_logic;  -- ufix1
        dataOut                           :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        startOut                          :   OUT   std_logic;  -- ufix1
        endOut                            :   OUT   std_logic;  -- ufix1
        validOut                          :   OUT   std_logic  -- ufix1
        );
END CRCGenerator;


ARCHITECTURE rtl OF CRCGenerator IS

  -- Component Declarations
  COMPONENT CRCGenControl
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          startIn                         :   IN    std_logic;  -- ufix1
          endIn                           :   IN    std_logic;  -- ufix1
          validIn                         :   IN    std_logic;  -- ufix1
          startOut                        :   OUT   std_logic;  -- ufix1
          processMsg                      :   OUT   std_logic;  -- ufix1
          padZero                         :   OUT   std_logic;  -- ufix1
          outputCRC                       :   OUT   std_logic;  -- ufix1
          endOut                          :   OUT   std_logic;  -- ufix1
          validOut                        :   OUT   std_logic;  -- ufix1
          regClr                          :   OUT   std_logic;  -- ufix1
          counter                         :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
          counter_outputCRC               :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
          );
  END COMPONENT;

  COMPONENT CRCGenCompute
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          datainReg                       :   IN    std_logic_vector(0 TO 7);  -- ufix1 [8]
          validIn                         :   IN    std_logic;  -- ufix1
          processMsg                      :   IN    std_logic;  -- ufix1
          padZero                         :   IN    std_logic;  -- ufix1
          counter                         :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          regClr                          :   IN    std_logic;  -- ufix1
          crcChecksum                     :   OUT   std_logic_vector(0 TO 23)  -- ufix1 [24]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : CRCGenControl
    USE ENTITY work.CRCGenControl(rtl);

  FOR ALL : CRCGenCompute
    USE ENTITY work.CRCGenCompute(rtl);

  -- Signals
  SIGNAL tstartout                        : std_logic;  -- ufix1
  SIGNAL processMsg                       : std_logic;  -- ufix1
  SIGNAL padZero                          : std_logic;  -- ufix1
  SIGNAL outputCRC                        : std_logic;  -- ufix1
  SIGNAL lastfout                         : std_logic;  -- ufix1
  SIGNAL validdata                        : std_logic;  -- ufix1
  SIGNAL regClr                           : std_logic;  -- ufix1
  SIGNAL counter                          : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL counter_opcrc                    : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL const0                           : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL msgenb                           : std_logic;  -- ufix1
  SIGNAL dataIn_unsigned                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL datainReg                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL datainBit1                       : std_logic;  -- ufix1
  SIGNAL datainBit2                       : std_logic;  -- ufix1
  SIGNAL datainBit3                       : std_logic;  -- ufix1
  SIGNAL datainBit4                       : std_logic;  -- ufix1
  SIGNAL datainBit5                       : std_logic;  -- ufix1
  SIGNAL datainBit6                       : std_logic;  -- ufix1
  SIGNAL datainBit7                       : std_logic;  -- ufix1
  SIGNAL datainBit8                       : std_logic;  -- ufix1
  SIGNAL alpha_out_1                      : std_logic;  -- ufix1
  SIGNAL alpha_1_reg                      : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_out_2                      : std_logic;  -- ufix1
  SIGNAL alpha_out_3                      : std_logic;  -- ufix1
  SIGNAL alpha_out_4                      : std_logic;  -- ufix1
  SIGNAL alpha_out_5                      : std_logic;  -- ufix1
  SIGNAL alpha_out_6                      : std_logic;  -- ufix1
  SIGNAL alpha_out_7                      : std_logic;  -- ufix1
  SIGNAL alpha_out_8                      : std_logic;  -- ufix1
  SIGNAL alpha_1_reg_1                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_2                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_3                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_4                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_5                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_6                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL alpha_1_reg_7                    : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL dataBuffer                       : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL datainBinVector                  : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL crcCheckSum                      : std_logic_vector(0 TO 23);  -- ufix1 [24]
  SIGNAL counter_opcrc_unsigned           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL crcp1                            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL crcp2                            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL crcp3                            : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL crcOut                           : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL msgcrc                           : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL tdataout                         : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL tdataout_0                       : std_logic;  -- ufix1
  SIGNAL tdataout_1                       : std_logic;  -- ufix1
  SIGNAL tdataout_2                       : std_logic;  -- ufix1
  SIGNAL tdataout_3                       : std_logic;  -- ufix1
  SIGNAL tdataout_4                       : std_logic;  -- ufix1
  SIGNAL tdataout_5                       : std_logic;  -- ufix1
  SIGNAL tdataout_6                       : std_logic;  -- ufix1
  SIGNAL tdataout_7                       : std_logic;  -- ufix1
  SIGNAL tdataoutInt                      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL dataOut_tmp                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL tstartoutGated                   : std_logic;  -- ufix1

BEGIN
  u_Controlsignal_inst : CRCGenControl
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              startIn => startIn,  -- ufix1
              endIn => endIn,  -- ufix1
              validIn => validIn,  -- ufix1
              startOut => tstartout,  -- ufix1
              processMsg => processMsg,  -- ufix1
              padZero => padZero,  -- ufix1
              outputCRC => outputCRC,  -- ufix1
              endOut => lastfout,  -- ufix1
              validOut => validdata,  -- ufix1
              regClr => regClr,  -- ufix1
              counter => counter,  -- ufix2
              counter_outputCRC => counter_opcrc  -- ufix2
              );

  u_ComputeCRC_inst : CRCGenCompute
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              datainReg => datainBinVector,  -- ufix1 [8]
              validIn => validIn,  -- ufix1
              processMsg => processMsg,  -- ufix1
              padZero => padZero,  -- ufix1
              counter => counter,  -- ufix2
              regClr => regClr,  -- ufix1
              crcChecksum => crcCheckSum  -- ufix1 [24]
              );

  -- Constant Zero
  const0(0) <= '0';
  const0(1) <= '0';
  const0(2) <= '0';
  const0(3) <= '0';
  const0(4) <= '0';
  const0(5) <= '0';
  const0(6) <= '0';
  const0(7) <= '0';

  msgenb <= processMsg OR padZero;

  dataIn_unsigned <= unsigned(dataIn);

  datainput_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      datainReg <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        datainReg <= dataIn_unsigned;
      END IF;
    END IF;
  END PROCESS datainput_register_process;


  -- Buffer Input Data
  datainBit1 <= datainReg(7);

  alpha_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha_1_reg <= (OTHERS => '0');
      alpha_1_reg_1 <= (OTHERS => '0');
      alpha_1_reg_2 <= (OTHERS => '0');
      alpha_1_reg_3 <= (OTHERS => '0');
      alpha_1_reg_4 <= (OTHERS => '0');
      alpha_1_reg_5 <= (OTHERS => '0');
      alpha_1_reg_6 <= (OTHERS => '0');
      alpha_1_reg_7 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND enb = '1' AND msgenb = '1' THEN
        alpha_1_reg(0) <= datainBit1;
        alpha_1_reg(1 TO 2) <= alpha_1_reg(0 TO 1);
        alpha_1_reg_1(0) <= datainBit2;
        alpha_1_reg_1(1 TO 2) <= alpha_1_reg_1(0 TO 1);
        alpha_1_reg_2(0) <= datainBit3;
        alpha_1_reg_2(1 TO 2) <= alpha_1_reg_2(0 TO 1);
        alpha_1_reg_3(0) <= datainBit4;
        alpha_1_reg_3(1 TO 2) <= alpha_1_reg_3(0 TO 1);
        alpha_1_reg_4(0) <= datainBit5;
        alpha_1_reg_4(1 TO 2) <= alpha_1_reg_4(0 TO 1);
        alpha_1_reg_5(0) <= datainBit6;
        alpha_1_reg_5(1 TO 2) <= alpha_1_reg_5(0 TO 1);
        alpha_1_reg_6(0) <= datainBit7;
        alpha_1_reg_6(1 TO 2) <= alpha_1_reg_6(0 TO 1);
        alpha_1_reg_7(0) <= datainBit8;
        alpha_1_reg_7(1 TO 2) <= alpha_1_reg_7(0 TO 1);
      END IF;
    END IF;
  END PROCESS alpha_1_process;

  alpha_out_1 <= alpha_1_reg(2);
  alpha_out_2 <= alpha_1_reg_1(2);
  alpha_out_3 <= alpha_1_reg_2(2);
  alpha_out_4 <= alpha_1_reg_3(2);
  alpha_out_5 <= alpha_1_reg_4(2);
  alpha_out_6 <= alpha_1_reg_5(2);
  alpha_out_7 <= alpha_1_reg_6(2);
  alpha_out_8 <= alpha_1_reg_7(2);

  datainBit2 <= datainReg(6);

  datainBit3 <= datainReg(5);

  datainBit4 <= datainReg(4);

  datainBit5 <= datainReg(3);

  datainBit6 <= datainReg(2);

  datainBit7 <= datainReg(1);

  datainBit8 <= datainReg(0);

  dataBuffer(0) <= alpha_out_1;
  dataBuffer(1) <= alpha_out_2;
  dataBuffer(2) <= alpha_out_3;
  dataBuffer(3) <= alpha_out_4;
  dataBuffer(4) <= alpha_out_5;
  dataBuffer(5) <= alpha_out_6;
  dataBuffer(6) <= alpha_out_7;
  dataBuffer(7) <= alpha_out_8;

  datainBinVector(0) <= datainBit1;
  datainBinVector(1) <= datainBit2;
  datainBinVector(2) <= datainBit3;
  datainBinVector(3) <= datainBit4;
  datainBinVector(4) <= datainBit5;
  datainBinVector(5) <= datainBit6;
  datainBinVector(6) <= datainBit7;
  datainBinVector(7) <= datainBit8;

  counter_opcrc_unsigned <= unsigned(counter_opcrc);

  -- Select CRC output bits
  crcp1(0) <= crcCheckSum(0);
  crcp1(1) <= crcCheckSum(1);
  crcp1(2) <= crcCheckSum(2);
  crcp1(3) <= crcCheckSum(3);
  crcp1(4) <= crcCheckSum(4);
  crcp1(5) <= crcCheckSum(5);
  crcp1(6) <= crcCheckSum(6);
  crcp1(7) <= crcCheckSum(7);

  -- Select CRC output bits
  crcp2(0) <= crcCheckSum(8);
  crcp2(1) <= crcCheckSum(9);
  crcp2(2) <= crcCheckSum(10);
  crcp2(3) <= crcCheckSum(11);
  crcp2(4) <= crcCheckSum(12);
  crcp2(5) <= crcCheckSum(13);
  crcp2(6) <= crcCheckSum(14);
  crcp2(7) <= crcCheckSum(15);

  -- Select CRC output bits
  crcp3(0) <= crcCheckSum(16);
  crcp3(1) <= crcCheckSum(17);
  crcp3(2) <= crcCheckSum(18);
  crcp3(3) <= crcCheckSum(19);
  crcp3(4) <= crcCheckSum(20);
  crcp3(5) <= crcCheckSum(21);
  crcp3(6) <= crcCheckSum(22);
  crcp3(7) <= crcCheckSum(23);

  multiportswitch_output : PROCESS (counter_opcrc_unsigned, crcp1, crcp2, crcp3)
  BEGIN
    IF counter_opcrc_unsigned = to_unsigned(16#0#, 2) THEN 
      crcOut <= crcp1;
    ELSIF counter_opcrc_unsigned = to_unsigned(16#1#, 2) THEN 
      crcOut <= crcp2;
    ELSE 
      crcOut <= crcp3;
    END IF;
  END PROCESS multiportswitch_output;


  
  msgcrc <= dataBuffer WHEN outputCRC = '0' ELSE
      crcOut;

  -- Output data and CRC CheckSum
  
  tdataout <= const0 WHEN validdata = '0' ELSE
      msgcrc;

  tdataout_0 <= tdataout(0);

  tdataout_1 <= tdataout(1);

  tdataout_2 <= tdataout(2);

  tdataout_3 <= tdataout(3);

  tdataout_4 <= tdataout(4);

  tdataout_5 <= tdataout(5);

  tdataout_6 <= tdataout(6);

  tdataout_7 <= tdataout(7);

  tdataoutInt <= unsigned'(tdataout_0 & tdataout_1 & tdataout_2 & tdataout_3 & tdataout_4 & tdataout_5 & tdataout_6 & tdataout_7);

  -- Data output register
  dataOut_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataOut_tmp <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataOut_tmp <= tdataoutInt;
      END IF;
    END IF;
  END PROCESS dataOut_register_process;


  dataOut <= std_logic_vector(dataOut_tmp);

  tstartoutGated <= tstartout AND validdata;

  -- startOut output register
  startOut_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startOut <= tstartoutGated;
      END IF;
    END IF;
  END PROCESS startOut_register_process;


  -- endOut output register
  endout_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endOut <= lastfout;
      END IF;
    END IF;
  END PROCESS endout_register_process;


  -- validOut output register
  validout_register_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOut <= validdata;
      END IF;
    END IF;
  END PROCESS validout_register_process;


END rtl;

