-- -------------------------------------------------------------
-- 
-- File Name: /home/apurvan/BBU/CRC_decoder_export/hdlsrc/ltehdlCRCDecoderModel/CRC_Decoder.vhd
-- Created: 2019-12-10 03:50:22
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CRC_Decoder
-- Source Path: ltehdlCRCDecoderModel/HDL Algorithm/CRC Decoder
-- Hierarchy Level: 1
-- 
-- CRC Decoder
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
--USE work.HDL_Algorithm_pkg.ALL;

ENTITY CRC_Decoder IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        in1_start                         :   IN    std_logic;
        in1_end                           :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        out1_start                        :   OUT   std_logic;
        out1_end                          :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic;
        out2                              :   OUT   std_logic_vector(23 DOWNTO 0)  -- ufix24
        );
END CRC_Decoder;


ARCHITECTURE rtl OF CRC_Decoder IS

  -- Component Declarations
  COMPONENT CRCGenerator
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          startIn                         :   IN    std_logic;
          endIn                           :   IN    std_logic;
          validIn                         :   IN    std_logic;
          dataOut                         :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          startOut                        :   OUT   std_logic;
          endOut                          :   OUT   std_logic;
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT endInNet
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          endin                           :   IN    std_logic;
          out_rsvd                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT CRCCompNet
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          in1                             :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          in2                             :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          en                              :   IN    std_logic;
          rst                             :   IN    std_logic;
          gateErrIn                       :   IN    std_logic;
          err                             :   OUT   std_logic_vector(23 DOWNTO 0)  -- ufix24
          );
  END COMPONENT;

  TYPE vector_of_unsigned8 IS ARRAY (NATURAL RANGE <>) OF unsigned(7 DOWNTO 0);
  
  -- Component Configuration Statements
  FOR ALL : CRCGenerator
    USE ENTITY work.CRCGenerator(rtl);

  FOR ALL : endInNet
    USE ENTITY work.endInNet(rtl);

  FOR ALL : CRCCompNet
    USE ENTITY work.CRCCompNet(rtl);

  -- Signals
  SIGNAL validin_ff_1                     : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL constant_rsvd                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL in0_unsigned                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL datain_ff_1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL dataInReg_reg                    : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL datain_reg                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL datain_crcgen                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL startin_ff_1                     : std_logic;
  SIGNAL startInReg_reg                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL startin_reg                      : std_logic;
  SIGNAL startin_crcgen                   : std_logic;
  SIGNAL endin_ff_1                       : std_logic;
  SIGNAL dataoutgen                       : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL startoutgen                      : std_logic;
  SIGNAL endoutgen                        : std_logic;
  SIGNAL validoutgen                      : std_logic;
  SIGNAL startOutReg_reg                  : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL startout_del                     : std_logic;
  SIGNAL startoutgen_gated                : std_logic;
  SIGNAL endOutdelay                      : std_logic;
  SIGNAL endOut_n                         : std_logic;
  SIGNAL endOut_nxt_state                 : std_logic;
  SIGNAL endOut_state                     : std_logic;
  SIGNAL endgate_sr                       : std_logic;
  SIGNAL local_rst_srcell_n               : std_logic;
  SIGNAL validOutTemp                     : std_logic;
  SIGNAL sel_dataoutmux                   : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL dataoutgen_unsigned              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL dataOutReg_reg                   : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL dataoutgen_del                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL dataoutgen_gated                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL dataOut_2del_reg                 : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL dataOut                          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL startOut_2del_reg                : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL startOut                         : std_logic;
  SIGNAL endOut                           : std_logic;
  SIGNAL endout_ff1                       : std_logic;
  SIGNAL endOut_1                         : std_logic;
  SIGNAL validOut_2del_reg                : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL validOut                         : std_logic;
  SIGNAL endin_ffdel                      : std_logic;
  SIGNAL enCRCBuf                         : std_logic;
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL crcReg_reg                       : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL crc_reg                          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL crc_reg_gated                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL crcRegDEPTH2_reg                 : vector_of_unsigned8(0 TO 4);  -- ufix8 [5]
  SIGNAL crc_to_mask                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL endout_large                     : std_logic;
  SIGNAL endout_orlarge                   : std_logic;
  SIGNAL enable_maskgen                   : std_logic;
  SIGNAL errout_word                      : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL errout_word_unsigned             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL err                              : unsigned(23 DOWNTO 0);  -- ufix24

BEGIN
  -- HDL CRC Generator
  u_HDLCRCGen_inst : CRCGenerator
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(datain_crcgen),  -- uint8
              startIn => startin_crcgen,
              endIn => endin_ff_1,
              validIn => validin_ff_1,
              dataOut => dataoutgen,  -- uint8
              startOut => startoutgen,
              endOut => endoutgen,
              validOut => validoutgen
              );

  u_endInEntity : endInNet
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              endin => endin_ff_1,
              out_rsvd => endin_ffdel
              );

  u_ErrPortEntity : CRCCompNet
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => dataoutgen,  -- uint8
              in2 => std_logic_vector(crc_to_mask),  -- uint8
              en => enable_maskgen,
              rst => startin_ff_1,
              gateErrIn => endout_ff1,
              err => errout_word  -- ufix24
              );

  validin_ff_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validin_ff_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validin_ff_1 <= in1_valid;
      END IF;
    END IF;
  END PROCESS validin_ff_process;


  
  switch_compare_1 <= '1' WHEN validin_ff_1 > '0' ELSE
      '0';

  constant_rsvd <= to_unsigned(16#00#, 8);

  in0_unsigned <= unsigned(in0);

  datain_ff_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      datain_ff_1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        datain_ff_1 <= in0_unsigned;
      END IF;
    END IF;
  END PROCESS datain_ff_process;


  dataInReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataInReg_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validin_ff_1 = '1' THEN
        dataInReg_reg(0) <= datain_ff_1;
        dataInReg_reg(1 TO 2) <= dataInReg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS dataInReg_process;

  datain_reg <= dataInReg_reg(2);

  
  datain_crcgen <= constant_rsvd WHEN switch_compare_1 = '0' ELSE
      datain_reg;

  startin_ff_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startin_ff_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startin_ff_1 <= in1_start;
      END IF;
    END IF;
  END PROCESS startin_ff_process;


  startInReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startInReg_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validin_ff_1 = '1' THEN
        startInReg_reg(0) <= startin_ff_1;
        startInReg_reg(1 TO 2) <= startInReg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS startInReg_process;

  startin_reg <= startInReg_reg(2);

  startin_crcgen <= validin_ff_1 AND startin_reg;

  endin_ff_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endin_ff_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endin_ff_1 <= in1_end;
      END IF;
    END IF;
  END PROCESS endin_ff_process;


  startOutReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startOutReg_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validoutgen = '1' THEN
        startOutReg_reg(0) <= startoutgen;
        startOutReg_reg(1 TO 2) <= startOutReg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS startOutReg_process;

  startout_del <= startOutReg_reg(2);

  startoutgen_gated <= startout_del AND validoutgen;

  endRegSR_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endOutdelay <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endOutdelay <= endoutgen;
      END IF;
    END IF;
  END PROCESS endRegSR_process;


  endOut_n <=  NOT endOutdelay;

  SRcell_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endOut_state <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF startoutgen = '1' THEN
          endOut_state <= '0';
        ELSE 
          endOut_state <= endOut_nxt_state;
        END IF;
      END IF;
    END IF;
  END PROCESS SRcell_process;


  endgate_sr <= endOut_n AND endOut_state;

  endOut_nxt_state <= startoutgen_gated OR endgate_sr;

  local_rst_srcell_n <=  NOT startoutgen;

  validOutTemp <= local_rst_srcell_n AND (endOut_nxt_state AND validoutgen);

  sel_dataoutmux <= validOutTemp AND validoutgen;

  
  switch_compare_1_1 <= '1' WHEN sel_dataoutmux > '0' ELSE
      '0';

  dataoutgen_unsigned <= unsigned(dataoutgen);

  dataOutReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataOutReg_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validoutgen = '1' THEN
        dataOutReg_reg(0) <= dataoutgen_unsigned;
        dataOutReg_reg(1 TO 2) <= dataOutReg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS dataOutReg_process;

  dataoutgen_del <= dataOutReg_reg(2);

  
  dataoutgen_gated <= constant_rsvd WHEN switch_compare_1_1 = '0' ELSE
      dataoutgen_del;

  dataOut_2del_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataOut_2del_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataOut_2del_reg(0) <= dataoutgen_gated;
        dataOut_2del_reg(1) <= dataOut_2del_reg(0);
      END IF;
    END IF;
  END PROCESS dataOut_2del_process;

  dataOut <= dataOut_2del_reg(1);

  out0 <= std_logic_vector(dataOut);

  startOut_2del_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      startOut_2del_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        startOut_2del_reg(0) <= startoutgen_gated;
        startOut_2del_reg(1) <= startOut_2del_reg(0);
      END IF;
    END IF;
  END PROCESS startOut_2del_process;

  startOut <= startOut_2del_reg(1);

  out1_start <= startOut;

  endOut <= validOutTemp AND endoutgen;

  endOut_1del1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endout_ff1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endout_ff1 <= endOut;
      END IF;
    END IF;
  END PROCESS endOut_1del1_process;


  endOut_1del2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endOut_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endOut_1 <= endout_ff1;
      END IF;
    END IF;
  END PROCESS endOut_1del2_process;


  out1_end <= endOut_1;

  validOut_2del_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOut_2del_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOut_2del_reg(0) <= validOutTemp;
        validOut_2del_reg(1) <= validOut_2del_reg(0);
      END IF;
    END IF;
  END PROCESS validOut_2del_process;

  validOut <= validOut_2del_reg(1);

  out1_valid <= validOut;

  enCRCBuf <= endin_ffdel OR validin_ff_1;

  
  switch_compare_1_2 <= '1' WHEN enCRCBuf > '0' ELSE
      '0';

  crcReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      crcReg_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND enCRCBuf = '1' THEN
        crcReg_reg(0) <= datain_ff_1;
        crcReg_reg(1 TO 2) <= crcReg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS crcReg_process;

  crc_reg <= crcReg_reg(2);

  
  crc_reg_gated <= constant_rsvd WHEN switch_compare_1_2 = '0' ELSE
      crc_reg;

  crcRegDEPTH2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      crcRegDEPTH2_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        crcRegDEPTH2_reg(0) <= crc_reg_gated;
        crcRegDEPTH2_reg(1 TO 4) <= crcRegDEPTH2_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS crcRegDEPTH2_process;

  crc_to_mask <= crcRegDEPTH2_reg(4);

  endout_largeFF_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      endout_large <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        endout_large <= endOut;
      END IF;
    END IF;
  END PROCESS endout_largeFF_process;


  endout_orlarge <= endout_large OR endOut;

  enable_maskgen <= endout_orlarge OR validoutgen;

  errout_word_unsigned <= unsigned(errout_word);

  errOut_1del_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      err <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        err <= errout_word_unsigned;
      END IF;
    END IF;
  END PROCESS errOut_1del_process;


  out2 <= std_logic_vector(err);

END rtl;

